## 脏读、不可重复读，幻读
* 脏读：事务T1将某一值修改，然后事务T2读取该值，此后T1因为某种原因撤销对该值的修改，这就导致了T2所读取到的数据是无效的。
* 不可重复读：事务T1读取某一数据，事务T2读取并修改了该数据，T1为了对读取值进行检验而再次读取该数据，便得到了不同的结果。
* 幻读：事务A读取与搜索条件相匹配的若干行。事务B以插入或删除行等方式来修改事务A的结果集，然后再提交。
    * 虽然事务A 在整个事务中对某些行添加了锁，但是对事务B 新增的记录并没有加锁，无法对未来的行加锁，索引导致幻读。

## Read uncommitted(读未提交)
* 该级别下，事务中的修改即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，也称为脏读。
* 实现原理：

    * 事务在读数据的时候并未对数据加锁。

    * 事务在修改数据的时候只对数据增加行级共享锁。



## Read Committed(读已提交)
* 大多数数据库的默认隔离级别（mysql 不是），该级别满足: 一个事务开始时候，只能看见已经提交的的事务所作的修改。也就是说一个事务从开始到提交之前所作的修改，所做的任务修改对其他事务都是不可见的。 这个级别有时候也叫做不可重复读。
* 实现原理：
    * 事务对当前被读取的数据加 行级共享锁（当读到时才加锁），一旦读完该行，立即释放该行级共享锁；
    * 事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。


## Repeatable read(可重复读)
* 该级别保证了同一个事务中多次读取的记录的结果是一致的。但是理论上无法解决幻读。所谓幻读指的是当某个事务在读取某个范围内的记录时，另外一个事务又插入新的记录，当之前的事务再次读取就会产生幻行。（这是mysql 的默认隔离级别）
* 实现原理：
    * 事务在读取某数据的瞬间（就是开始读取的瞬间），必须先对其加 行级共享锁，直到事务结束才释放；
    * 事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。



## Serializable(串行化)
* 强制事务的串行执行，直接使用表锁。
* 实现原理：
    * 事务在读取数据时，必须先对其加 表级共享锁 ，直到事务结束才释放；

    * 事务在更新数据时，必须先对其加 表级排他锁 ，直到事务结束才释放





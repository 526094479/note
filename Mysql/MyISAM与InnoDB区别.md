* MyISAM：它是基于传统的ISAM类型，ISAM是Indexed Sequential Access Method (有索引的顺序访问方法) 的缩写，它是存储记录和文件的标准方法。不是事务安全的，而且不支持外键，如果执行大量的select，insert MyISAM比较适合。
* InnoDB：默认表类型。支持事务安全的引擎，支持外键、行锁、事务是他的最大特点。如果有大量的update和insert，建议使用InnoDB，特别是针对多个并发和QPS较高的情况。
*** 
* 表锁差异
    * myisam只支持表级锁，用户在操作myisam表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。也可以通过lock table命令来锁表，这样操作主要是可以模仿事务，但是消耗非常大，一般只在实验演示中使用。
    * Innodb支持事务和行级锁，是innodb的最大特色。
    * Innodb的行锁模式有以下几种：共享锁，排他锁，意向共享锁(表锁)，意向排他锁(表锁)，间隙锁。当语句没有使用索引，innodb不能确定操作的行，这个时候就使用的意向锁，也就是表锁
*** 
* 数据库文件差异
    * MyISAM 
        * myisam属于堆表
        * myisam在磁盘存储上有三个文件，每个文件名以表名开头，扩展名指出文件类型。.frm 用于存储表的定义 .MYD 用于存放数据 .MYI 用于存放表索引
        * myisam表还支持三种不同的存储格式：静态表 动态表 压缩表
    * InnoDB 
        * innodb属于索引组织表
        * innodb有两种存储方式，共享表空间存储和多表空间存储
            * 如果使用共享表空间，那么所有表的数据文件和索引文件都保存在一个表空间里，一个表空间可以有多个文件，通过innodb_data_file_path和innodb_data_home_dir参数设置共享表空间的位置和名字，一般共享表空间的名字叫ibdata1-n。
            * 如果使用多表空间，那么每个表都有一个表空间文件用于存储每个表的数据和索引，文件名以表名开头，以.ibd为扩展名。
        * 两种存储方式的表结构和myisam一样，以表名开头，扩展名是.frm。
*** 
* 索引差异
    * 关于自动增长
        * myisam引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，他可以根据前面几列进行排序后递增。
        * innodb引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列。
    * 关于主键
        * myisam允许没有任何索引和主键的表存在，myisam的索引都是保存行的地址。
        * innodb引擎如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，innodb的数据是主索引的一部分(聚簇索引)，附加索引保存的是主索引的值。
    * 关于count() 函数
        * myisam保存有表的总行数，如果select count(*) from table;会直接取出出该值
        * innodb没有保存表的总行数，如果使用select count(*) from table；就会遍历整个表，消耗相当大，但是在加了wehre  条件后，myisam和innodb处理的方式都一样。
   mysql的各种查询）
    * 索引保存位置
        * myisam的索引以表名+.MYI文件分别保存。
        * innodb的索引和数据一起保存在表空间里。

### InnoDB 如何存储文件
* MySQL 使用 InnoDB 存储表时，会将表的定义和数据索引等信息分开存储，其中前者存储在 .frm 文件中，后者存储在 .ibd 文件中。
    * .frm ：无论在 MySQL 中选择了哪个存储引擎，所有的 MySQL 表都会在硬盘上创建一个 .frm 文件用来描述表的格式或者说定义； .frm 文件的格式在不同的平台上都是相同的。
    * .ibd ：InnoDB 中用于存储数据的文件总共有两个部分，一是系统表空间文件，包括 ibdata1、 ibdata2 等文件，其中存储了 InnoDB 系统信息和用户数据库表数据和索引，是所有表公用的。当打开 innodb_file_per_table 选项时， .ibd 文件就是每一个表独有的表空间，文件存储了当前表的数据和相关的索引数据
* 表空间
innodb存储引擎其数据是按照表空间进行管理的。新建一个数据库时，innodb存储引擎会初始化一个名为ibdata1 的表空间文件，默认情况下，这个文件会存储所有表的数据，以及我们所熟知但看不到的系统表sys_tables、sys_columns、sys_indexes 、sys_fields等。此外，还会存储用来保证数据完整性的回滚段数据，当然这部分数据在新版本的MySQL中，已经可以通过参数来设置回滚段的存储位置了。


这个文件所存储的内容主要就是B+树（索引），一个表可以有多个索引，也就是在一个文件中，可以存储多个索引，而如果一个表没有索引的话，用来存储数据的被称为聚簇索引，也就是说这也是一个索引。最终的结论是，ibd文件存储的就是一个表的所有索引数据。 索引文件有段（segment）,簇（extends）（有的文章翻译为区），页面（page）组成。
* 段（Segement)
 段是表空间文件中的主要组织结构，它是一个逻辑概念，用来管理物理文件，是构成索引、表、回滚段的基本元素。表空间是由各个段组成的，常见的段有数据段、索引段、回滚段等。InnoDB存储引擎表是索引组织的（index organized），因此数据即索引，索引即数据。那么数据段即为B+树的页节点（上图的leaf node segment），索引段即为B+树的非索引节点（上图的non-leaf node segment）。
创建一个索引（B+树）时会同时创建两个段，分别是内节点段和叶子段，内节点段用来管理（存储）B+树非叶子（页面）的数据，叶子段用来管理（存储）B+树叶子节点的数据；也就是说，在索引数据量一直增长的过程中，所有新的存储空间的申请，都是从“段”这个概念中申请的。
* 区/簇（extents）
簇是由64个连续的页组成的，每个页大小为16KB，即每个簇的大小为1MB。簇是构成段的基本元素，一个段由若干个簇构成。一个簇是物理上连续分配的一个段空间，每一个段至少会有一个簇，在创建一个段时会创建一个默认的簇。如果存储数据时，一个簇已经不足以放下更多的数据，此时需要从这个段中分配一个新的簇来存放新的数据。一个段所管理的空间大小是无限的，可以一直扩展下去，但是扩展的最小单位就是簇。
* 页面（Page)
页是InnoDB磁盘管理的最小单位。常见的页类型有：
    * 数据页（B-tree Node）
    * Undo页（Undo Log Page）
    * 系统页（System Page）
    * 事务数据页（Transaction system Page）
    * 插入缓冲位图页（Insert Buffer Bitmap）
    * 插入缓冲空闲列表页（Insert Buffer Free List）
    * 未压缩的二进制大对象页（Uncompressed BLOB Page）
    * 压缩的二进制大对象页（Compressed BLOB Page）
页在逻辑上（页面号都是从小到大连续的）及物理上都是连续的。在向表中插入数据时，如果一个页面已经被写完，系统会从当前簇中分配一个新的空闲页面处理使用，如果当前簇中的64个页面都被分配完，系统会从当前页面所在段中分配一个新的簇，然后再从这个簇中分配一个新的页面来使用；

* 一条记录占用空间过大会导致跨页，造成额外的性能开销。另外数据库以行为单位将数据加载到内存中，这样表中字段长度较短且访问频率较高，内存能加载更多的数据，命中率更高，减少了磁盘IO，从而提升了数据库性能。
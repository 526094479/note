# 区别
* 解析执行：将字节码一行一行地翻译为机器码执行。
* 编译执行：以方法为单位，将字节码一次性翻译为机器码后执行。

# Java 里的解析执行和编译执行
* 在编译示时期，我们通过将源代码编译成.class ，配合JVM这种跨平台的抽象，屏蔽了底层计算机操作系统和硬件的区别，实现了“一次编译，到处运行” 。 而在运行时期，目前主流的JVM 都是混合模式（-Xmixed），即解释运行 和编译运行配合使用。
* 以 Oracle JDK提供的HotSpot虚拟机为例，在HotSpot虚拟机中，提供了两种编译模式：解释执行 和 即时编译（JIT，Just-In-Time）。解释执行即逐条翻译字节码为可运行的机器码，而即时编译则以方法为单位将字节码翻译成机器码（上述提到的“编译执行”）。前者的优势在于不用等待，后者则在实际运行当中效率更高。
* 即时编译存在的意义在于它是提高程序性能的重要手段之一。根据“二八定律”（即：百分之二十的代码占据百分之八十的系统资源），对于大部分不常用的代码，我们无需耗时间将之编译为机器码，而是采用解释执行的方式，用到就去逐条解释运行；对于一些仅占据小部分的热点代码（可认为是反复执行的重要代码），则可将之翻译为符合机器的机器码高效执行，提高程序的效率，此为运行时的即时编译。
* 为了满足不同的场景，HotSpot虚拟机内置了多个即时编译器：C1,C2与Graal。Graal 是Java10正式引入的实验性即时编译器。从Java7开始，HotSpot虚拟机默认采用分层编译的方式：热点方法首先被C1编译器编译，而后 热点方法中的热点再进一步被C2编译（理解为二次编译，根据前面的运行计算出更优的编译优化）。为了不干扰程序的正常运行，JIT编译时放在额外的线程中执行的，HotSpot根据实际CPU的资源，以 1:2的比例分配给C1和C2线程数。在计算机资源充足的情况，字节码的解释运行和编译运行时可以同时进行，编译执行完后的机器码会在下次调用该方法时启动，已替换原本的解释执行（意思就是已经翻译出效率更高的机器码，自然替换原来的相对低效率执行的方法）。
* 由此，可以看出Java 不单单是解析执行，编译执行在Java 性能优化中彰显重要的作用。

# 解释执行的优化
* 栈顶缓存
    * 在方法执行的过程中，有很多操作要将值放进操作数栈，这导致了寄存器和内存要不断地交换数据。Sun JDK采用了一个栈顶缓存，即将本来位于操作数栈顶的值直接缓存在寄存器伤，使得大部分只需要一个值的操作不必将数据放进操作数栈，直接在寄存器计算，然后返回操作数栈。
* 部分栈帧共享
    * 当一个方法调用另外一个方法时，通常传入另外一个方法的参数为已存放在操作数栈的数据。Sun JDK做了优化：就是当调用方法时，后一方法可将前一方法的操作数栈作为当前方法的局部变量，从而节省数据copy 带来的消耗。

# 编译执行的优化
* client complier （C1，采用线性扫描寄存器分配算法）
    * 方法内联，即把调用到的方法的指令直接植入当前方法中。
    * 去虚拟化，在装载class 文件后，进行类层次的分析，如发现接口的方法只提供一个实现类，那么对于调用了此方法的代码，也可以进行方法内联，从而提高执行性能
    * 冗余削除
* server complier（C2，采用传统的图着色寄存器分配算法）
    * 逃逸分析是C2进行很多优化的基础。逃逸分析是指根据运行状况来判断方法中的变量是否会被外部读取，如不会则认为此变量是逃逸的。。
    * 标量替换，如果创建的对象并没用到其中的全部变量，则可以节省一定的内存。对于代码执行，也无须去找对象的引用，也会更快。
    
    * 栈上分配，如果确定一个对象的作用于不会逃逸出方法之外，那么可以将这个对象分配在栈上，对象所占用的内存空间就可以随栈帧出栈而销毁。在一般应用中，不会逃逸的局部对象所占的比例很大，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁了，无须通过垃圾收集器回收，可以减小垃圾收集器的负载。
    * 同步削除，指如果发现同步的对象并未逃逸，那么也没有同步的必要了，在C2编译时会直接去掉同步。
    
    
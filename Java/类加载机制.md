# 类的生命周期
  * 类的生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段。其中验证、准备、解析3个部分统称连接。
  * 加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的。类加载过程必须按照这个顺序**开始**

# 类加载的过程
  * 加载
    * 通过一个类的全限定名来获取定义此类的二进制字节流（不一定通过Class 文件获取）
    * 将这个字节流所代表 的静态存储结构转化为方法区的运行时数据结构
    * 在内存生成代表这个类的java.lang.Class 对象，作为方法区这个类的各种数据的访问入口

  * 验证
    * 文件格式验证
    * 元数据验证
    * 字节码验证
    * 符号引用验证

  * 准备
    * 正式为类变量分配内存并设置类变量的初始值。（0，null什么的）
    * 如果类字段的属性表中存在ConstantValue 属性，在准备阶段value 就会被初始化为ConstantValue 的值。（例如final 修饰的就会为value 生成ConstantValue 属性）

  * 解析
    1. 类或接口的解析（假设当前类为D，把未解析的符号引用N解析为一个类或接口C的直接引用）
      * 如果C不是数组，则把代表N的全限定名传给D的类加载器去加载类C。在加载过程中，可能会触发相关类的加载动作（例如这个类的父类或实现的接口）
      * 如果C是数组，并且数组元素为对象，则按照上面的加载数组元素类型。接着由虚拟机生成一个代表这个数组维度和元素的数组对象。

    2. 字段解析（先解析该字段所属的类或接口C的符号引用）
      * 如果C本身包含与目标匹配的字段，则返回这个字段的直接引用。
      * 否则，如果C实现了接口，按继承关系从下往上递归搜索各个接口和它的父接口。如果包含匹配则返回。
      * 否则，如果C不是java.lang.Object ，则按照继承从下往上递归搜索父类。如果包含匹配则返回。

    3. 类方法解析（先解析出类方法表的class_index 项中索引的方法所属的类或接口的符号引用C）
      * 如果C不是接口，则在C中查找相匹配的方法。有则返回
      * 否则，在C的父类中递归查找
      * 否则，在C实现的接口及他们的父接口查找，如果存在匹配，则C是一个抽象类。抛AbstractMethodError 异常。

    4. 接口方法解析（先解析出类方法表的class_index 项中索引的方法所属的类或接口的符号引用C）
      * 如果C不是类，则在接口C查找匹配的方法
      * 否则在C的父接口递归查找

 

  